// Copyright (c) ZeroC, Inc.
//
// Ice version 3.8.0-alpha.0
//
// <auto-generated>
//
// Generated from file 'Test.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>

import Foundation
import Ice

public struct S: Swift.Hashable {
    public var v: Swift.Int32 = 0

    public init() {}

    public init(v: Swift.Int32) {
        self.v = v
    }
}

/// An `Ice.InputStream` extension to read `S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> S {
        var v = S()
        v.v = try self.read()
        return v
    }

    /// Read an optional `S?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as S
    }
}

/// An `Ice.OutputStream` extension to write `S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: S) {
        self.write(v.v)
    }

    /// Write an optional `S?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public typealias SMap = [Swift.String: S]

/// Helper class to read and write `SMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SMapHelper {
    /// Read a `SMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SMap {
        let sz = try Swift.Int(istr.readSize())
        var v = SMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: S = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `SMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `SMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `SMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: SMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias SSeq = [S]

/// Helper class to read and write `SSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct SSeqHelper {
    /// Read a `SSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> SSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = SSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `SSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> SSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `SSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: SSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `SSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: SSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

@_documentation(visibility: internal)
public class C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C() -> Ice.ValueTypeResolver {
        return C_TypeResolver()
    }
}

open class C: Ice.Value {
    public var s: S = S()

    public required init() {}

    public init(s: S) {
        self.s = s
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::C" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

public typealias CMap = [Swift.String: C?]

/// Helper class to read and write `CMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CMapHelper {
    /// Read a `CMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CMap {
        let sz = try Swift.Int(istr.readSize())
        var v = CMap()
        let e = Ice.DictEntryArray<Swift.String, C?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as C?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, C?>(key: key, value: $0)
            }
            try istr.read(C.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }

    /// Read an optional `CMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `CMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `CMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: CMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias CSeq = [C?]

/// Helper class to read and write `CSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct CSeqHelper {
    /// Read a `CSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> CSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = CSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(C.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `CSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> CSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `CSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: CSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `CSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: CSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public enum E1: Swift.UInt8 {
    case v1 = 0
    case v2 = 1
    case v3 = 2
    public init() {
        self = .v1
    }
}

/// An `Ice.InputStream` extension to read `E1` enumerated values from the stream.
public extension Ice.InputStream {
    /// Read an enumerated value.
    ///
    /// - Returns:  The enumerated value.
    func read() throws -> E1 {
        let rawValue: Swift.UInt8 = try read(enumMaxValue: 2)
        guard let val = E1(rawValue: rawValue) else {
            throw Ice.MarshalException("invalid enum value")
        }
        return val
    }

    /// Read an optional enumerated value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The enumerated value.
    func read(tag: Swift.Int32) throws -> E1? {
        guard try readOptional(tag: tag, expectedFormat: .Size) else {
            return nil
        }
        return try read() as E1
    }
}

/// An `Ice.OutputStream` extension to write `E1` enumerated values to the stream.
public extension Ice.OutputStream {
    /// Writes an enumerated value to the stream.
    ///
    /// - Parameter v: The enumerator to write.
    func write(_ v: E1) {
        write(enum: v.rawValue, maxValue: 2)
    }

    /// Writes an optional enumerated value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The enumerator to write.
    func write(tag: Swift.Int32, value: E1?) {
        guard let v = value else {
            return
        }
        write(tag: tag, val: v.rawValue, maxValue: 2)
    }
}

public struct S1: Swift.Hashable {
    public var s: Swift.String = ""

    public init() {}

    public init(s: Swift.String) {
        self.s = s
    }
}

/// An `Ice.InputStream` extension to read `S1` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S1` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> S1 {
        var v = S1()
        v.s = try self.read()
        return v
    }

    /// Read an optional `S1?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S1? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S1
    }
}

/// An `Ice.OutputStream` extension to write `S1` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S1` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: S1) {
        self.write(v.s)
    }

    /// Write an optional `S1?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: S1?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

public typealias S1Seq = [S1]

/// Helper class to read and write `S1Seq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S1SeqHelper {
    /// Read a `S1Seq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S1Seq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = S1Seq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: S1 = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `S1Seq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S1Seq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `S1Seq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S1Seq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `S1Seq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: S1Seq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias S1Map = [Swift.String: S1]

/// Helper class to read and write `S1Map` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct S1MapHelper {
    /// Read a `S1Map` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> S1Map {
        let sz = try Swift.Int(istr.readSize())
        var v = S1Map()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: S1 = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `S1Map?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> S1Map? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `S1Map` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: S1Map) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `S1Map?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: S1Map?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

@_documentation(visibility: internal)
public class C1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C1() -> Ice.ValueTypeResolver {
        return C1_TypeResolver()
    }
}

open class C1: Ice.Value {
    public var s: Swift.String = ""

    public required init() {}

    public init(s: Swift.String) {
        self.s = s
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::C1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

public class S2 {
    public var E1: E1 = .v1
    typealias Test_S1 = S1
    public var S1: S1 = Test_S1()
    public var C1: C1? = nil
    typealias Test_S1Seq = S1Seq
    public var S1Seq: S1Seq = Test_S1Seq()
    typealias Test_S1Map = S1Map
    public var S1Map: S1Map = Test_S1Map()

    public init() {}

    public init(E1: E1, S1: S1, C1: C1?, S1Seq: S1Seq, S1Map: S1Map) {
        self.E1 = E1
        self.S1 = S1
        self.C1 = C1
        self.S1Seq = S1Seq
        self.S1Map = S1Map
    }
}

/// An `Ice.InputStream` extension to read `S2` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `S2` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> S2 {
        let v = S2()
        v.E1 = try self.read()
        v.S1 = try self.read()
        try self.read(C1.self) { v.C1 = $0 }
        v.S1Seq = try S1SeqHelper.read(from: self)
        v.S1Map = try S1MapHelper.read(from: self)
        return v
    }

    /// Read an optional `S2?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> S2? {
        guard try readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try skip(4)
        return try read() as S2
    }
}

/// An `Ice.OutputStream` extension to write `S2` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `S2` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: S2) {
        self.write(v.E1)
        self.write(v.S1)
        self.write(v.C1)
        S1SeqHelper.write(to: self, value: v.S1Seq)
        S1MapHelper.write(to: self, value: v.S1Map)
    }

    /// Write an optional `S2?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: S2?) {
        if let v = value {
            if writeOptional(tag: tag, format: .FSize) {
                let pos = startSize()
                write(v)
                endSize(position: pos)
            }
        }
    }
}

@_documentation(visibility: internal)
public class C2_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return C2.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_C2() -> Ice.ValueTypeResolver {
        return C2_TypeResolver()
    }
}

open class C2: Ice.Value {
    public var E1: E1 = .v1
    typealias Test_S1 = S1
    public var S1: S1 = Test_S1()
    public var C1: C1? = nil
    typealias Test_S1Seq = S1Seq
    public var S1Seq: S1Seq = Test_S1Seq()
    typealias Test_S1Map = S1Map
    public var S1Map: S1Map = Test_S1Map()

    public required init() {}

    public init(E1: E1, S1: S1, C1: C1?, S1Seq: S1Seq, S1Map: S1Map) {
        self.E1 = E1
        self.S1 = S1
        self.C1 = C1
        self.S1Seq = S1Seq
        self.S1Map = S1Map
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::C2" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.E1 = try istr.read()
        self.S1 = try istr.read()
        typealias Test_C1 = C1
        try istr.read(Test_C1.self) { self.C1 = $0 }
        self.S1Seq = try S1SeqHelper.read(from: istr)
        self.S1Map = try S1MapHelper.read(from: istr)
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: C2.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.E1)
        ostr.write(self.S1)
        ostr.write(self.C1)
        S1SeqHelper.write(to: ostr, value: self.S1Seq)
        S1MapHelper.write(to: ostr, value: self.S1Map)
        ostr.endSlice()
    }
}

/// Traits for Slice interface `I`.
public struct ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::I"]
    public static let staticId = "::Test::I"
}

public protocol IPrx: Ice.ObjectPrx {}

private final class IPrxI: Ice.ObjectPrxI, IPrx {
    public override class func ice_staticId() -> Swift.String {
        return ITraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: IPrx.Protocol) throws -> IPrx {
    try communicator.makeProxyImpl(proxyString) as IPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> IPrx? {
    return try await IPrxI.checkedCast(prx: prx, facet: facet, context: context) as IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil) -> IPrx {
    return IPrxI.uncheckedCast(prx: prx, facet: facet) as IPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: IPrx.Protocol) -> Swift.String {
    return ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: IPrx.Protocol) throws -> IPrx? {
        return try read() as IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: IPrx.Protocol) throws -> IPrx? {
        return try read(tag: tag) as IPrxI?
    }
}

public extension IPrx {
    func opS(_ iceP_s1: S, context: Ice.Context? = nil) async throws -> (returnValue: S, s2: S) {
        return try await _impl._invoke(operation: "opS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: S = try istr.read()
                                           let iceP_returnValue: S = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opSSeq(_ iceP_s1: SSeq, context: Ice.Context? = nil) async throws -> (returnValue: SSeq, s2: SSeq) {
        return try await _impl._invoke(operation: "opSSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           SSeqHelper.write(to: ostr, value: iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: SSeq = try SSeqHelper.read(from: istr)
                                           let iceP_returnValue: SSeq = try SSeqHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opSMap(_ iceP_s1: SMap, context: Ice.Context? = nil) async throws -> (returnValue: SMap, s2: SMap) {
        return try await _impl._invoke(operation: "opSMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           SMapHelper.write(to: ostr, value: iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: SMap = try SMapHelper.read(from: istr)
                                           let iceP_returnValue: SMap = try SMapHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opC(_ iceP_c1: C?, context: Ice.Context? = nil) async throws -> (returnValue: C?, c2: C?) {
        return try await _impl._invoke(operation: "opC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_c2: C?
                                           try istr.read(C.self) { iceP_c2 = $0 }
                                           var iceP_returnValue: C?
                                           try istr.read(C.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func opCSeq(_ iceP_s1: CSeq, context: Ice.Context? = nil) async throws -> (returnValue: CSeq, s2: CSeq) {
        return try await _impl._invoke(operation: "opCSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           CSeqHelper.write(to: ostr, value: iceP_s1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_s2: CSeq = try CSeqHelper.read(from: istr)
                                           let iceP_returnValue: CSeq = try CSeqHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opCMap(_ iceP_c1: CMap, context: Ice.Context? = nil) async throws -> (returnValue: CMap, c2: CMap) {
        return try await _impl._invoke(operation: "opCMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           CMapHelper.write(to: ostr, value: iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_c2: CMap = try CMapHelper.read(from: istr)
                                           let iceP_returnValue: CMap = try CMapHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func opE1(_ iceP_E1: E1, context: Ice.Context? = nil) async throws -> E1 {
        return try await _impl._invoke(operation: "opE1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_E1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: E1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opS1(_ iceP_S1: S1, context: Ice.Context? = nil) async throws -> S1 {
        return try await _impl._invoke(operation: "opS1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_S1)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: S1 = try istr.read()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opC1(_ iceP_C1: C1?, context: Ice.Context? = nil) async throws -> C1? {
        return try await _impl._invoke(operation: "opC1",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_C1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_returnValue: C1?
                                           try istr.read(C1.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opS1Seq(_ iceP_S1Seq: S1Seq, context: Ice.Context? = nil) async throws -> S1Seq {
        return try await _impl._invoke(operation: "opS1Seq",
                                       mode: .Normal,
                                       write: { ostr in
                                           S1SeqHelper.write(to: ostr, value: iceP_S1Seq)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: S1Seq = try S1SeqHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func opS1Map(_ iceP_S1Map: S1Map, context: Ice.Context? = nil) async throws -> S1Map {
        return try await _impl._invoke(operation: "opS1Map",
                                       mode: .Normal,
                                       write: { ostr in
                                           S1MapHelper.write(to: ostr, value: iceP_S1Map)
                                       },
                                       read: { istr in
                                           let iceP_returnValue: S1Map = try S1MapHelper.read(from: istr)
                                           return iceP_returnValue
                                       },
                                       context: context)
    }

    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }
}

public typealias IMap = [Swift.String: IPrx?]

/// Helper class to read and write `IMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct IMapHelper {
    /// Read a `IMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> IMap {
        let sz = try Swift.Int(istr.readSize())
        var v = IMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: IPrx? = try istr.read(IPrx.self)
            v[key] = value
        }
        return v
    }

    /// Read an optional `IMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> IMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `IMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: IMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `IMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: IMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias ISeq = [IPrx?]

/// Helper class to read and write `ISeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct ISeqHelper {
    /// Read a `ISeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> ISeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = ISeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: IPrx? = try istr.read(IPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `ISeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> ISeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `ISeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: ISeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `ISeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: ISeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public struct InnerS: Swift.Hashable {
    public var v: Swift.Int32 = 0

    public init() {}

    public init(v: Swift.Int32) {
        self.v = v
    }
}

/// An `Ice.InputStream` extension to read `InnerS` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `InnerS` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> InnerS {
        var v = InnerS()
        v.v = try self.read()
        return v
    }

    /// Read an optional `InnerS?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> InnerS? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as InnerS
    }
}

/// An `Ice.OutputStream` extension to write `InnerS` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `InnerS` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: InnerS) {
        self.write(v.v)
    }

    /// Write an optional `InnerS?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: InnerS?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public struct InnerInner2S: Swift.Hashable {
    public var v: Swift.Int32 = 0

    public init() {}

    public init(v: Swift.Int32) {
        self.v = v
    }
}

/// An `Ice.InputStream` extension to read `InnerInner2S` structured values from the stream.
public extension Ice.InputStream {
    /// Read a `InnerInner2S` structured value from the stream.
    ///
    /// - Returns: The structured value read from the stream.
    func read() throws -> InnerInner2S {
        var v = InnerInner2S()
        v.v = try self.read()
        return v
    }

    /// Read an optional `InnerInner2S?` structured value from the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The structured value read from the stream.
    func read(tag: Swift.Int32) throws -> InnerInner2S? {
        guard try readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try skipSize()
        return try read() as InnerInner2S
    }
}

/// An `Ice.OutputStream` extension to write `InnerInner2S` structured values from the stream.
public extension Ice.OutputStream {
    /// Write a `InnerInner2S` structured value to the stream.
    ///
    /// - Parameter v: The value to write to the stream.
    func write(_ v: InnerInner2S) {
        self.write(v.v)
    }

    /// Write an optional `InnerInner2S?` structured value to the stream.
    ///
    /// - Parameter tag: The numeric tag associated with the value.
    /// - Parameter value: The value to write to the stream.
    func write(tag: Swift.Int32, value: InnerInner2S?) {
        if let v = value {
            if writeOptional(tag: tag, format: .VSize) {
                write(size: 4)
                write(v)
            }
        }
    }
}

public typealias InnerInner2SMap = [Swift.String: InnerInner2S]

/// Helper class to read and write `InnerInner2SMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2SMapHelper {
    /// Read a `InnerInner2SMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2SMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerInner2SMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: InnerInner2S = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `InnerInner2SMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2SMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerInner2SMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2SMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `InnerInner2SMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerInner2SMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerInner2SSeq = [InnerInner2S]

/// Helper class to read and write `InnerInner2SSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2SSeqHelper {
    /// Read a `InnerInner2SSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2SSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = InnerInner2SSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InnerInner2S = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `InnerInner2SSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2SSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `InnerInner2SSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2SSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InnerInner2SSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerInner2SSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

@_documentation(visibility: internal)
public class InnerInner2C_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InnerInner2C.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_Inner2_C() -> Ice.ValueTypeResolver {
        return InnerInner2C_TypeResolver()
    }
}

open class InnerInner2C: Ice.Value {
    public var s: InnerInner2S = InnerInner2S()

    public required init() {}

    public init(s: InnerInner2S) {
        self.s = s
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Inner::Inner2::C" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerInner2C.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

public typealias InnerInner2CMap = [Swift.String: InnerInner2C?]

/// Helper class to read and write `InnerInner2CMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2CMapHelper {
    /// Read a `InnerInner2CMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2CMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerInner2CMap()
        let e = Ice.DictEntryArray<Swift.String, InnerInner2C?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as InnerInner2C?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, InnerInner2C?>(key: key, value: $0)
            }
            try istr.read(InnerInner2C.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }

    /// Read an optional `InnerInner2CMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2CMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerInner2CMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2CMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `InnerInner2CMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerInner2CMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerInner2CSeq = [InnerInner2C?]

/// Helper class to read and write `InnerInner2CSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2CSeqHelper {
    /// Read a `InnerInner2CSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2CSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = InnerInner2CSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(InnerInner2C.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `InnerInner2CSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2CSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerInner2CSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2CSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InnerInner2CSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerInner2CSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `InnerInner2I`.
public struct InnerInner2ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Inner::Inner2::I"]
    public static let staticId = "::Test::Inner::Inner2::I"
}

public protocol InnerInner2IPrx: Ice.ObjectPrx {}

private final class InnerInner2IPrxI: Ice.ObjectPrxI, InnerInner2IPrx {
    public override class func ice_staticId() -> Swift.String {
        return InnerInner2ITraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: InnerInner2IPrx.Protocol) throws -> InnerInner2IPrx {
    try communicator.makeProxyImpl(proxyString) as InnerInner2IPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InnerInner2IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> InnerInner2IPrx? {
    return try await InnerInner2IPrxI.checkedCast(prx: prx, facet: facet, context: context) as InnerInner2IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: InnerInner2IPrx.Protocol, facet: Swift.String? = nil) -> InnerInner2IPrx {
    return InnerInner2IPrxI.uncheckedCast(prx: prx, facet: facet) as InnerInner2IPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: InnerInner2IPrx.Protocol) -> Swift.String {
    return InnerInner2ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `InnerInner2IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: InnerInner2IPrx.Protocol) throws -> InnerInner2IPrx? {
        return try read() as InnerInner2IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: InnerInner2IPrx.Protocol) throws -> InnerInner2IPrx? {
        return try read(tag: tag) as InnerInner2IPrxI?
    }
}

public extension InnerInner2IPrx {
    func opS(_ iceP_s1: InnerInner2S, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2S, s2: InnerInner2S) {
        return try await _impl._invoke(operation: "opS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: InnerInner2S = try istr.read()
                                           let iceP_returnValue: InnerInner2S = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opSSeq(_ iceP_s1: InnerInner2SSeq, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2SSeq, s2: InnerInner2SSeq) {
        return try await _impl._invoke(operation: "opSSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           InnerInner2SSeqHelper.write(to: ostr, value: iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                           let iceP_returnValue: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opSMap(_ iceP_s1: InnerInner2SMap, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2SMap, s2: InnerInner2SMap) {
        return try await _impl._invoke(operation: "opSMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           InnerInner2SMapHelper.write(to: ostr, value: iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                           let iceP_returnValue: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opC(_ iceP_c1: InnerInner2C?, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2C?, c2: InnerInner2C?) {
        return try await _impl._invoke(operation: "opC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_c2: InnerInner2C?
                                           try istr.read(InnerInner2C.self) { iceP_c2 = $0 }
                                           var iceP_returnValue: InnerInner2C?
                                           try istr.read(InnerInner2C.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func opCSeq(_ iceP_c1: InnerInner2CSeq, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2CSeq, c2: InnerInner2CSeq) {
        return try await _impl._invoke(operation: "opCSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           InnerInner2CSeqHelper.write(to: ostr, value: iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_c2: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                           let iceP_returnValue: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func opCMap(_ iceP_c1: InnerInner2CMap, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2CMap, c2: InnerInner2CMap) {
        return try await _impl._invoke(operation: "opCMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           InnerInner2CMapHelper.write(to: ostr, value: iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_c2: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                           let iceP_returnValue: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }
}

public typealias InnerInner2IMap = [Swift.String: InnerInner2IPrx?]

/// Helper class to read and write `InnerInner2IMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2IMapHelper {
    /// Read a `InnerInner2IMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2IMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerInner2IMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: InnerInner2IPrx? = try istr.read(InnerInner2IPrx.self)
            v[key] = value
        }
        return v
    }

    /// Read an optional `InnerInner2IMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2IMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerInner2IMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2IMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `InnerInner2IMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerInner2IMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerInner2ISeq = [InnerInner2IPrx?]

/// Helper class to read and write `InnerInner2ISeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerInner2ISeqHelper {
    /// Read a `InnerInner2ISeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerInner2ISeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = InnerInner2ISeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InnerInner2IPrx? = try istr.read(InnerInner2IPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `InnerInner2ISeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerInner2ISeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerInner2ISeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerInner2ISeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InnerInner2ISeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerInner2ISeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

@_documentation(visibility: internal)
public class InnerC_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return InnerC.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Test_Inner_C() -> Ice.ValueTypeResolver {
        return InnerC_TypeResolver()
    }
}

open class InnerC: Ice.Value {
    public var s: InnerS = InnerS()

    public required init() {}

    public init(s: InnerS) {
        self.s = s
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Test::Inner::C" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.s = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: InnerC.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.s)
        ostr.endSlice()
    }
}

public typealias InnerSSeq = [InnerInner2S]

/// Helper class to read and write `InnerSSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerSSeqHelper {
    /// Read a `InnerSSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerSSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 4)
        var v = InnerSSeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InnerInner2S = try istr.read()
            v.append(j)
        }
        return v
    }

    /// Read an optional `InnerSSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerSSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .VSize) else {
            return nil
        }
        try istr.skipSize()
        return try read(from: istr)
    }

    /// Write a `InnerSSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerSSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InnerSSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerSSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptionalVSize(tag: tag, len: val.count, elemSize: 4) {
            write(to: ostr, value: val)
        }
    }
}

public typealias InnerSMap = [Swift.String: InnerInner2S]

/// Helper class to read and write `InnerSMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerSMapHelper {
    /// Read a `InnerSMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerSMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerSMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: InnerInner2S = try istr.read()
            v[key] = value
        }
        return v
    }

    /// Read an optional `InnerSMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerSMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerSMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerSMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `InnerSMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerSMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerCMap = [Swift.String: InnerInner2C?]

/// Helper class to read and write `InnerCMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerCMapHelper {
    /// Read a `InnerCMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerCMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerCMap()
        let e = Ice.DictEntryArray<Swift.String, InnerInner2C?>(size: sz)
        for i in 0 ..< sz {
            let key: Swift.String = try istr.read()
            v[key] = nil as InnerInner2C?
            Swift.withUnsafeMutablePointer(to: &v[key, default:nil]) {
                e.values[i] = Ice.DictEntry<Swift.String, InnerInner2C?>(key: key, value: $0)
            }
            try istr.read(InnerInner2C.self) { e.values[i].value.pointee = $0 }
        }
        for i in 0..<sz {
            Swift.withUnsafeMutablePointer(to: &v[e.values[i].key, default:nil]) {
                e.values[i].value = $0
            }
        }
        return v
    }

    /// Read an optional `InnerCMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerCMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerCMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerCMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `InnerCMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerCMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerCSeq = [InnerInner2C?]

/// Helper class to read and write `InnerCSeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerCSeqHelper {
    /// Read a `InnerCSeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerCSeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 1)
        var v = InnerCSeq(repeating: nil, count: sz)
        for i in 0 ..< sz {
            try Swift.withUnsafeMutablePointer(to: &v[i]) { p in
                try istr.read(InnerInner2C.self) { p.pointee = $0 }
            }
        }
        return v
    }

    /// Read an optional `InnerCSeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerCSeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerCSeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerCSeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InnerCSeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerCSeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `InnerI`.
public struct InnerITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Test::Inner::I"]
    public static let staticId = "::Test::Inner::I"
}

public protocol InnerIPrx: Ice.ObjectPrx {}

private final class InnerIPrxI: Ice.ObjectPrxI, InnerIPrx {
    public override class func ice_staticId() -> Swift.String {
        return InnerITraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: InnerIPrx.Protocol) throws -> InnerIPrx {
    try communicator.makeProxyImpl(proxyString) as InnerIPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InnerIPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> InnerIPrx? {
    return try await InnerIPrxI.checkedCast(prx: prx, facet: facet, context: context) as InnerIPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: InnerIPrx.Protocol, facet: Swift.String? = nil) -> InnerIPrx {
    return InnerIPrxI.uncheckedCast(prx: prx, facet: facet) as InnerIPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: InnerIPrx.Protocol) -> Swift.String {
    return InnerITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `InnerIPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: InnerIPrx.Protocol) throws -> InnerIPrx? {
        return try read() as InnerIPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: InnerIPrx.Protocol) throws -> InnerIPrx? {
        return try read(tag: tag) as InnerIPrxI?
    }
}

public extension InnerIPrx {
    func opS(_ iceP_s1: InnerInner2S, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2S, s2: InnerInner2S) {
        return try await _impl._invoke(operation: "opS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: InnerInner2S = try istr.read()
                                           let iceP_returnValue: InnerInner2S = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opSSeq(_ iceP_s1: InnerInner2SSeq, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2SSeq, s2: InnerInner2SSeq) {
        return try await _impl._invoke(operation: "opSSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           InnerInner2SSeqHelper.write(to: ostr, value: iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                           let iceP_returnValue: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opSMap(_ iceP_s1: InnerInner2SMap, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2SMap, s2: InnerInner2SMap) {
        return try await _impl._invoke(operation: "opSMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           InnerInner2SMapHelper.write(to: ostr, value: iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                           let iceP_returnValue: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opC(_ iceP_c1: InnerInner2C?, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2C?, c2: InnerInner2C?) {
        return try await _impl._invoke(operation: "opC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_c2: InnerInner2C?
                                           try istr.read(InnerInner2C.self) { iceP_c2 = $0 }
                                           var iceP_returnValue: InnerInner2C?
                                           try istr.read(InnerInner2C.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func opCSeq(_ iceP_c1: InnerInner2CSeq, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2CSeq, c2: InnerInner2CSeq) {
        return try await _impl._invoke(operation: "opCSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           InnerInner2CSeqHelper.write(to: ostr, value: iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_c2: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                           let iceP_returnValue: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func opCMap(_ iceP_c1: InnerInner2CMap, context: Ice.Context? = nil) async throws -> (returnValue: InnerInner2CMap, c2: InnerInner2CMap) {
        return try await _impl._invoke(operation: "opCMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           InnerInner2CMapHelper.write(to: ostr, value: iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_c2: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                           let iceP_returnValue: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }
}

public typealias InnerIMap = [Swift.String: InnerIPrx?]

/// Helper class to read and write `InnerIMap` dictionary values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerIMapHelper {
    /// Read a `InnerIMap` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerIMap {
        let sz = try Swift.Int(istr.readSize())
        var v = InnerIMap()
        for _ in 0 ..< sz {
            let key: Swift.String = try istr.read()
            let value: InnerIPrx? = try istr.read(InnerIPrx.self)
            v[key] = value
        }
        return v
    }

    /// Read an optional `InnerIMap?` dictionary from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The dictionary read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerIMap? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerIMap` dictionary to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerIMap) {
        ostr.write(size: v.count)
        for (key, value) in v {
            ostr.write(key)
            ostr.write(value)
        }
    }

    /// Write an optional `InnerIMap?` dictionary to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The dictionary value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, tag: Swift.Int32, value v: InnerIMap?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

public typealias InnerISeq = [InnerIPrx?]

/// Helper class to read and write `InnerISeq` sequence values from
/// `Ice.InputStream` and `Ice.OutputStream`.
public struct InnerISeqHelper {
    /// Read a `InnerISeq` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream) throws -> InnerISeq {
        let sz = try istr.readAndCheckSeqSize(minSize: 2)
        var v = InnerISeq()
        v.reserveCapacity(sz)
        for _ in 0 ..< sz {
            let j: InnerIPrx? = try istr.read(InnerIPrx.self)
            v.append(j)
        }
        return v
    }

    /// Read an optional `InnerISeq?` sequence from the stream.
    ///
    /// - Parameter istr: The stream to read from.
    /// - Parameter tag: The numeric tag associated with the value.
    ///
    /// - Returns: The sequence read from the stream.
    public static func read(from istr: Ice.InputStream, tag: Swift.Int32) throws -> InnerISeq? {
        guard try istr.readOptional(tag: tag, expectedFormat: .FSize) else {
            return nil
        }
        try istr.skip(4)
        return try read(from: istr)
    }

    /// Write a `InnerISeq` sequence to the stream.
    ///
    /// - Parameter ostr: The stream to write to.
    /// - Parameter value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream, value v: InnerISeq) {
        ostr.write(size: v.count)
        for item in v {
            ostr.write(item)
        }
    }

    /// Write an optional `InnerISeq?` sequence to the stream.
    ///
    /// - Parameters:
    ///   - ostr: The stream to write to.
    ///   - tag: The numeric tag associated with the value.
    ///   - value: The sequence value to write to the stream.
    public static func write(to ostr: Ice.OutputStream,  tag: Swift.Int32, value v: InnerISeq?) {
        guard let val = v else {
            return
        }
        if ostr.writeOptional(tag: tag, format: .FSize) {
            let pos = ostr.startSize()
            write(to: ostr, value: val)
            ostr.endSize(position: pos)
        }
    }
}

/// Traits for Slice interface `InnerTestInner2I`.
public struct InnerTestInner2ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Inner::Test::Inner2::I"]
    public static let staticId = "::Inner::Test::Inner2::I"
}

public protocol InnerTestInner2IPrx: Ice.ObjectPrx {}

private final class InnerTestInner2IPrxI: Ice.ObjectPrxI, InnerTestInner2IPrx {
    public override class func ice_staticId() -> Swift.String {
        return InnerTestInner2ITraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: InnerTestInner2IPrx.Protocol) throws -> InnerTestInner2IPrx {
    try communicator.makeProxyImpl(proxyString) as InnerTestInner2IPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: InnerTestInner2IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> InnerTestInner2IPrx? {
    return try await InnerTestInner2IPrxI.checkedCast(prx: prx, facet: facet, context: context) as InnerTestInner2IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: InnerTestInner2IPrx.Protocol, facet: Swift.String? = nil) -> InnerTestInner2IPrx {
    return InnerTestInner2IPrxI.uncheckedCast(prx: prx, facet: facet) as InnerTestInner2IPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: InnerTestInner2IPrx.Protocol) -> Swift.String {
    return InnerTestInner2ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `InnerTestInner2IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: InnerTestInner2IPrx.Protocol) throws -> InnerTestInner2IPrx? {
        return try read() as InnerTestInner2IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: InnerTestInner2IPrx.Protocol) throws -> InnerTestInner2IPrx? {
        return try read(tag: tag) as InnerTestInner2IPrxI?
    }
}

public extension InnerTestInner2IPrx {
    func opS(_ iceP_s1: S, context: Ice.Context? = nil) async throws -> (returnValue: S, s2: S) {
        return try await _impl._invoke(operation: "opS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: S = try istr.read()
                                           let iceP_returnValue: S = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opSSeq(_ iceP_s1: SSeq, context: Ice.Context? = nil) async throws -> (returnValue: SSeq, s2: SSeq) {
        return try await _impl._invoke(operation: "opSSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           SSeqHelper.write(to: ostr, value: iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: SSeq = try SSeqHelper.read(from: istr)
                                           let iceP_returnValue: SSeq = try SSeqHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opSMap(_ iceP_s1: SMap, context: Ice.Context? = nil) async throws -> (returnValue: SMap, s2: SMap) {
        return try await _impl._invoke(operation: "opSMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           SMapHelper.write(to: ostr, value: iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: SMap = try SMapHelper.read(from: istr)
                                           let iceP_returnValue: SMap = try SMapHelper.read(from: istr)
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opC(_ iceP_c1: C?, context: Ice.Context? = nil) async throws -> (returnValue: C?, c2: C?) {
        return try await _impl._invoke(operation: "opC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_c2: C?
                                           try istr.read(C.self) { iceP_c2 = $0 }
                                           var iceP_returnValue: C?
                                           try istr.read(C.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func opCSeq(_ iceP_c1: CSeq, context: Ice.Context? = nil) async throws -> (returnValue: CSeq, c2: CSeq) {
        return try await _impl._invoke(operation: "opCSeq",
                                       mode: .Normal,
                                       write: { ostr in
                                           CSeqHelper.write(to: ostr, value: iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_c2: CSeq = try CSeqHelper.read(from: istr)
                                           let iceP_returnValue: CSeq = try CSeqHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func opCMap(_ iceP_c1: CMap, context: Ice.Context? = nil) async throws -> (returnValue: CMap, c2: CMap) {
        return try await _impl._invoke(operation: "opCMap",
                                       mode: .Normal,
                                       write: { ostr in
                                           CMapHelper.write(to: ostr, value: iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           let iceP_c2: CMap = try CMapHelper.read(from: istr)
                                           let iceP_returnValue: CMap = try CMapHelper.read(from: istr)
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }

    func shutdown(context: Ice.Context? = nil) async throws -> Swift.Void {
        return try await _impl._invoke(operation: "shutdown",
                                       mode: .Normal,
                                       context: context)
    }
}

@_documentation(visibility: internal)
public class FooClass1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return FooClass1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func Inner_Class1() -> Ice.ValueTypeResolver {
        return FooClass1_TypeResolver()
    }
}

open class FooClass1: Ice.Value {
    public var l: Swift.Int64 = 0

    public required init() {}

    public init(l: Swift.Int64) {
        self.l = l
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::Inner::Class1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.l = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: FooClass1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.l)
        ostr.endSlice()
    }
}

/// Traits for Slice interface `FooI`.
public struct FooITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::Inner::I"]
    public static let staticId = "::Inner::I"
}

public protocol FooIPrx: Ice.ObjectPrx {}

private final class FooIPrxI: Ice.ObjectPrxI, FooIPrx {
    public override class func ice_staticId() -> Swift.String {
        return FooITraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: FooIPrx.Protocol) throws -> FooIPrx {
    try communicator.makeProxyImpl(proxyString) as FooIPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: FooIPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> FooIPrx? {
    return try await FooIPrxI.checkedCast(prx: prx, facet: facet, context: context) as FooIPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: FooIPrx.Protocol, facet: Swift.String? = nil) -> FooIPrx {
    return FooIPrxI.uncheckedCast(prx: prx, facet: facet) as FooIPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: FooIPrx.Protocol) -> Swift.String {
    return FooITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `FooIPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: FooIPrx.Protocol) throws -> FooIPrx? {
        return try read() as FooIPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: FooIPrx.Protocol) throws -> FooIPrx? {
        return try read(tag: tag) as FooIPrxI?
    }
}

public extension FooIPrx {
    func opS(_ iceP_s1: InnerS, context: Ice.Context? = nil) async throws -> (returnValue: InnerS, s2: InnerS) {
        return try await _impl._invoke(operation: "opS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: InnerS = try istr.read()
                                           let iceP_returnValue: InnerS = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opC(_ iceP_c1: FooClass1?, context: Ice.Context? = nil) async throws -> (returnValue: FooClass1?, c2: FooClass1?) {
        return try await _impl._invoke(operation: "opC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_c2: FooClass1?
                                           try istr.read(FooClass1.self) { iceP_c2 = $0 }
                                           var iceP_returnValue: FooClass1?
                                           try istr.read(FooClass1.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }
}

@_documentation(visibility: internal)
public class Class1_TypeResolver: Ice.ValueTypeResolver {
    public override func type() -> Ice.Value.Type {
        return Class1.self
    }
}

public extension Ice.ClassResolver {
    @objc static func NoPrefix_Class1() -> Ice.ValueTypeResolver {
        return Class1_TypeResolver()
    }
}

open class Class1: Ice.Value {
    public var l: Swift.Int64 = 0

    public required init() {}

    public init(l: Swift.Int64) {
        self.l = l
    }

    /// - Returns: The Slice type ID of the interface supported by this object.
    open override class func ice_staticId() -> Swift.String { "::NoPrefix::Class1" }

    open override func _iceReadImpl(from istr: Ice.InputStream) throws {
        _ = try istr.startSlice()
        self.l = try istr.read()
        try istr.endSlice()
    }

    open override func _iceWriteImpl(to ostr: Ice.OutputStream) {
        ostr.startSlice(typeId: Class1.ice_staticId(), compactId: -1, last: true)
        ostr.write(self.l)
        ostr.endSlice()
    }
}

/// Traits for Slice interface `I`.
public struct ITraits: Ice.SliceTraits {
    public static let staticIds = ["::Ice::Object", "::NoPrefix::I"]
    public static let staticId = "::NoPrefix::I"
}

public protocol IPrx: Ice.ObjectPrx {}

private final class IPrxI: Ice.ObjectPrxI, IPrx {
    public override class func ice_staticId() -> Swift.String {
        return ITraits.staticId
    }
}

/// Makes a new proxy from a communicator and a proxy string.
///
/// - Parameters:
///    - communicator: The communicator of the new proxy.
///    - proxyString: The proxy string to parse.
///    - type: The type of the new proxy.
///
/// - Throws: `Ice.ParseException` if the proxy string is invalid.
///
/// - Returns: A new proxy with the requested type.
public func makeProxy(communicator: Ice.Communicator, proxyString: String, type: IPrx.Protocol) throws -> IPrx {
    try communicator.makeProxyImpl(proxyString) as IPrxI
}

/// Casts a proxy to the requested type. This call contacts the server and verifies that the object
/// implements this type.
///
/// It will throw a local exception if a communication error occurs. You can optionally supply a
/// facet name and a context map.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///   - context: The optional context dictionary for the remote invocation.
///
/// - Returns: A proxy with the requested type or nil if the objet does not support this type.
///
/// - Throws: `Ice.LocalException` if a communication error occurs.
public func checkedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil, context: Ice.Context? = nil) async throws -> IPrx? {
    return try await IPrxI.checkedCast(prx: prx, facet: facet, context: context) as IPrxI?
}

/// Downcasts the given proxy to this type without contacting the remote server.
///
/// - Parameters:
///   - prx: The proxy to be cast.
///   - type: The proxy type to cast to.
///   - facet: The optional name of the desired facet.
///
/// - Returns: A proxy with the requested type.
public func uncheckedCast(prx: Ice.ObjectPrx, type: IPrx.Protocol, facet: Swift.String? = nil) -> IPrx {
    return IPrxI.uncheckedCast(prx: prx, facet: facet) as IPrxI
}

/// Returns the Slice type id of the interface associated with this proxy type.
///
/// - Parameter type:  The proxy type to retrieve the type id.
///
/// - Returns: The type id of the interface associated with this proxy type.
public func ice_staticId(_ type: IPrx.Protocol) -> Swift.String {
    return ITraits.staticId
}

/// Extension to `Ice.InputStream` class to support reading proxies of type
/// `IPrx`.
public extension Ice.InputStream {
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(_ type: IPrx.Protocol) throws -> IPrx? {
        return try read() as IPrxI?
    }
    /// Extracts a proxy from the stream. The stream must have been initialized with a communicator.
    ///
    /// - Parameter tag:  The numeric tag associated with the value.
    /// - Parameter type: The type of the proxy to be extracted.
    ///
    /// - Returns: The extracted proxy.
    func read(tag: Swift.Int32, type: IPrx.Protocol) throws -> IPrx? {
        return try read(tag: tag) as IPrxI?
    }
}

public extension IPrx {
    func opS(_ iceP_s1: InnerS, context: Ice.Context? = nil) async throws -> (returnValue: InnerS, s2: InnerS) {
        return try await _impl._invoke(operation: "opS",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_s1)
                                       },
                                       read: { istr in
                                           let iceP_s2: InnerS = try istr.read()
                                           let iceP_returnValue: InnerS = try istr.read()
                                           return (iceP_returnValue, iceP_s2)
                                       },
                                       context: context)
    }

    func opC(_ iceP_c1: Class1?, context: Ice.Context? = nil) async throws -> (returnValue: Class1?, c2: Class1?) {
        return try await _impl._invoke(operation: "opC",
                                       mode: .Normal,
                                       write: { ostr in
                                           ostr.write(iceP_c1)
                                           ostr.writePendingValues()
                                       },
                                       read: { istr in
                                           var iceP_c2: Class1?
                                           try istr.read(Class1.self) { iceP_c2 = $0 }
                                           var iceP_returnValue: Class1?
                                           try istr.read(Class1.self) { iceP_returnValue = $0 }
                                           try istr.readPendingValues()
                                           return (iceP_returnValue, iceP_c2)
                                       },
                                       context: context)
    }
}


/// Dispatcher for `I` servants.
public struct IDisp: Ice.Dispatcher {
    public let servant: I
    private static let defaultObject = Ice.ObjectI<ITraits>()

    public init(_ servant: I) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "opS":
            try await servant._iceD_opS(request)
        case "opSSeq":
            try await servant._iceD_opSSeq(request)
        case "opSMap":
            try await servant._iceD_opSMap(request)
        case "opC":
            try await servant._iceD_opC(request)
        case "opCSeq":
            try await servant._iceD_opCSeq(request)
        case "opCMap":
            try await servant._iceD_opCMap(request)
        case "opE1":
            try await servant._iceD_opE1(request)
        case "opS1":
            try await servant._iceD_opS1(request)
        case "opC1":
            try await servant._iceD_opC1(request)
        case "opS1Seq":
            try await servant._iceD_opS1Seq(request)
        case "opS1Map":
            try await servant._iceD_opS1Map(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol I {
    func opS(s1: S, current: Ice.Current) async throws -> (returnValue: S, s2: S)

    func opSSeq(s1: SSeq, current: Ice.Current) async throws -> (returnValue: SSeq, s2: SSeq)

    func opSMap(s1: SMap, current: Ice.Current) async throws -> (returnValue: SMap, s2: SMap)

    func opC(c1: C?, current: Ice.Current) async throws -> (returnValue: C?, c2: C?)

    func opCSeq(s1: CSeq, current: Ice.Current) async throws -> (returnValue: CSeq, s2: CSeq)

    func opCMap(c1: CMap, current: Ice.Current) async throws -> (returnValue: CMap, c2: CMap)

    func opE1(E1: E1, current: Ice.Current) async throws -> E1

    func opS1(S1: S1, current: Ice.Current) async throws -> S1

    func opC1(C1: C1?, current: Ice.Current) async throws -> C1?

    func opS1Seq(S1Seq: S1Seq, current: Ice.Current) async throws -> S1Seq

    func opS1Map(S1Map: S1Map, current: Ice.Current) async throws -> S1Map

    func shutdown(current: Ice.Current) async throws
}


/// Dispatcher for `InnerInner2I` servants.
public struct InnerInner2IDisp: Ice.Dispatcher {
    public let servant: InnerInner2I
    private static let defaultObject = Ice.ObjectI<InnerInner2ITraits>()

    public init(_ servant: InnerInner2I) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "opS":
            try await servant._iceD_opS(request)
        case "opSSeq":
            try await servant._iceD_opSSeq(request)
        case "opSMap":
            try await servant._iceD_opSMap(request)
        case "opC":
            try await servant._iceD_opC(request)
        case "opCSeq":
            try await servant._iceD_opCSeq(request)
        case "opCMap":
            try await servant._iceD_opCMap(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? InnerInner2IDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? InnerInner2IDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? InnerInner2IDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? InnerInner2IDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol InnerInner2I {
    func opS(s1: InnerInner2S, current: Ice.Current) async throws -> (returnValue: InnerInner2S, s2: InnerInner2S)

    func opSSeq(s1: InnerInner2SSeq, current: Ice.Current) async throws -> (returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)

    func opSMap(s1: InnerInner2SMap, current: Ice.Current) async throws -> (returnValue: InnerInner2SMap, s2: InnerInner2SMap)

    func opC(c1: InnerInner2C?, current: Ice.Current) async throws -> (returnValue: InnerInner2C?, c2: InnerInner2C?)

    func opCSeq(c1: InnerInner2CSeq, current: Ice.Current) async throws -> (returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)

    func opCMap(c1: InnerInner2CMap, current: Ice.Current) async throws -> (returnValue: InnerInner2CMap, c2: InnerInner2CMap)

    func shutdown(current: Ice.Current) async throws
}


/// Dispatcher for `InnerI` servants.
public struct InnerIDisp: Ice.Dispatcher {
    public let servant: InnerI
    private static let defaultObject = Ice.ObjectI<InnerITraits>()

    public init(_ servant: InnerI) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "opS":
            try await servant._iceD_opS(request)
        case "opSSeq":
            try await servant._iceD_opSSeq(request)
        case "opSMap":
            try await servant._iceD_opSMap(request)
        case "opC":
            try await servant._iceD_opC(request)
        case "opCSeq":
            try await servant._iceD_opCSeq(request)
        case "opCMap":
            try await servant._iceD_opCMap(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? InnerIDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? InnerIDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? InnerIDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? InnerIDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol InnerI {
    func opS(s1: InnerInner2S, current: Ice.Current) async throws -> (returnValue: InnerInner2S, s2: InnerInner2S)

    func opSSeq(s1: InnerInner2SSeq, current: Ice.Current) async throws -> (returnValue: InnerInner2SSeq, s2: InnerInner2SSeq)

    func opSMap(s1: InnerInner2SMap, current: Ice.Current) async throws -> (returnValue: InnerInner2SMap, s2: InnerInner2SMap)

    func opC(c1: InnerInner2C?, current: Ice.Current) async throws -> (returnValue: InnerInner2C?, c2: InnerInner2C?)

    func opCSeq(c1: InnerInner2CSeq, current: Ice.Current) async throws -> (returnValue: InnerInner2CSeq, c2: InnerInner2CSeq)

    func opCMap(c1: InnerInner2CMap, current: Ice.Current) async throws -> (returnValue: InnerInner2CMap, c2: InnerInner2CMap)

    func shutdown(current: Ice.Current) async throws
}


/// Dispatcher for `InnerTestInner2I` servants.
public struct InnerTestInner2IDisp: Ice.Dispatcher {
    public let servant: InnerTestInner2I
    private static let defaultObject = Ice.ObjectI<InnerTestInner2ITraits>()

    public init(_ servant: InnerTestInner2I) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "opS":
            try await servant._iceD_opS(request)
        case "opSSeq":
            try await servant._iceD_opSSeq(request)
        case "opSMap":
            try await servant._iceD_opSMap(request)
        case "opC":
            try await servant._iceD_opC(request)
        case "opCSeq":
            try await servant._iceD_opCSeq(request)
        case "opCMap":
            try await servant._iceD_opCMap(request)
        case "shutdown":
            try await servant._iceD_shutdown(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? InnerTestInner2IDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? InnerTestInner2IDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? InnerTestInner2IDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? InnerTestInner2IDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol InnerTestInner2I {
    func opS(s1: S, current: Ice.Current) async throws -> (returnValue: S, s2: S)

    func opSSeq(s1: SSeq, current: Ice.Current) async throws -> (returnValue: SSeq, s2: SSeq)

    func opSMap(s1: SMap, current: Ice.Current) async throws -> (returnValue: SMap, s2: SMap)

    func opC(c1: C?, current: Ice.Current) async throws -> (returnValue: C?, c2: C?)

    func opCSeq(c1: CSeq, current: Ice.Current) async throws -> (returnValue: CSeq, c2: CSeq)

    func opCMap(c1: CMap, current: Ice.Current) async throws -> (returnValue: CMap, c2: CMap)

    func shutdown(current: Ice.Current) async throws
}


/// Dispatcher for `FooI` servants.
public struct FooIDisp: Ice.Dispatcher {
    public let servant: FooI
    private static let defaultObject = Ice.ObjectI<FooITraits>()

    public init(_ servant: FooI) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "opS":
            try await servant._iceD_opS(request)
        case "opC":
            try await servant._iceD_opC(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? FooIDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? FooIDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? FooIDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? FooIDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol FooI {
    func opS(s1: InnerS, current: Ice.Current) async throws -> (returnValue: InnerS, s2: InnerS)

    func opC(c1: FooClass1?, current: Ice.Current) async throws -> (returnValue: FooClass1?, c2: FooClass1?)
}


/// Dispatcher for `I` servants.
public struct IDisp: Ice.Dispatcher {
    public let servant: I
    private static let defaultObject = Ice.ObjectI<ITraits>()

    public init(_ servant: I) {
        self.servant = servant
    }

    public func dispatch(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        switch request.current.operation {
        case "opS":
            try await servant._iceD_opS(request)
        case "opC":
            try await servant._iceD_opC(request)
        case "ice_id":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_id(request)
        case "ice_ids":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_ids(request)
        case "ice_isA":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_isA(request)
        case "ice_ping":
            try await (servant as? Ice.Object ?? IDisp.defaultObject)._iceD_ice_ping(request)
        default:
            throw Ice.OperationNotExistException()
        }
    }
}

public protocol I {
    func opS(s1: InnerS, current: Ice.Current) async throws -> (returnValue: InnerS, s2: InnerS)

    func opC(c1: Class1?, current: Ice.Current) async throws -> (returnValue: Class1?, c2: Class1?)
}

extension I {
    public func _iceD_opS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: S = try istr.read()
        let result = try await self.opS(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: SSeq = try SSeqHelper.read(from: istr)
        let result = try await self.opSSeq(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            SSeqHelper.write(to: ostr, value: iceP_s2)
            SSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: SMap = try SMapHelper.read(from: istr)
        let result = try await self.opSMap(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            SMapHelper.write(to: ostr, value: iceP_s2)
            SMapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_c1: C?
        try istr.read(C.self) { iceP_c1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opC(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: CSeq = try CSeqHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCSeq(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            CSeqHelper.write(to: ostr, value: iceP_s2)
            CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_c1: CMap = try CMapHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCMap(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            CMapHelper.write(to: ostr, value: iceP_c2)
            CMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opE1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_E1: E1 = try istr.read()
        let result = try await self.opE1(E1: iceP_E1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opS1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_S1: S1 = try istr.read()
        let result = try await self.opS1(S1: iceP_S1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opC1(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_C1: C1?
        try istr.read(C1.self) { iceP_C1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opC1(C1: iceP_C1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opS1Seq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_S1Seq: S1Seq = try S1SeqHelper.read(from: istr)
        let result = try await self.opS1Seq(S1Seq: iceP_S1Seq, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            S1SeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opS1Map(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_S1Map: S1Map = try S1MapHelper.read(from: istr)
        let result = try await self.opS1Map(S1Map: iceP_S1Map, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let iceP_returnValue = value
            S1MapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension InnerInner2I {
    public func _iceD_opS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: InnerInner2S = try istr.read()
        let result = try await self.opS(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
        let result = try await self.opSSeq(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            InnerInner2SSeqHelper.write(to: ostr, value: iceP_s2)
            InnerInner2SSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
        let result = try await self.opSMap(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            InnerInner2SMapHelper.write(to: ostr, value: iceP_s2)
            InnerInner2SMapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_c1: InnerInner2C?
        try istr.read(InnerInner2C.self) { iceP_c1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opC(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_c1: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCSeq(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            InnerInner2CSeqHelper.write(to: ostr, value: iceP_c2)
            InnerInner2CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_c1: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCMap(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            InnerInner2CMapHelper.write(to: ostr, value: iceP_c2)
            InnerInner2CMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension InnerI {
    public func _iceD_opS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: InnerInner2S = try istr.read()
        let result = try await self.opS(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: InnerInner2SSeq = try InnerInner2SSeqHelper.read(from: istr)
        let result = try await self.opSSeq(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            InnerInner2SSeqHelper.write(to: ostr, value: iceP_s2)
            InnerInner2SSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: InnerInner2SMap = try InnerInner2SMapHelper.read(from: istr)
        let result = try await self.opSMap(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            InnerInner2SMapHelper.write(to: ostr, value: iceP_s2)
            InnerInner2SMapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_c1: InnerInner2C?
        try istr.read(InnerInner2C.self) { iceP_c1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opC(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_c1: InnerInner2CSeq = try InnerInner2CSeqHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCSeq(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            InnerInner2CSeqHelper.write(to: ostr, value: iceP_c2)
            InnerInner2CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_c1: InnerInner2CMap = try InnerInner2CMapHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCMap(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            InnerInner2CMapHelper.write(to: ostr, value: iceP_c2)
            InnerInner2CMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension InnerTestInner2I {
    public func _iceD_opS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: S = try istr.read()
        let result = try await self.opS(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opSSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: SSeq = try SSeqHelper.read(from: istr)
        let result = try await self.opSSeq(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            SSeqHelper.write(to: ostr, value: iceP_s2)
            SSeqHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opSMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: SMap = try SMapHelper.read(from: istr)
        let result = try await self.opSMap(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            SMapHelper.write(to: ostr, value: iceP_s2)
            SMapHelper.write(to: ostr, value: iceP_returnValue)
        }
    }

    public func _iceD_opC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_c1: C?
        try istr.read(C.self) { iceP_c1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opC(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCSeq(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_c1: CSeq = try CSeqHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCSeq(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            CSeqHelper.write(to: ostr, value: iceP_c2)
            CSeqHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_opCMap(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_c1: CMap = try CMapHelper.read(from: istr)
        try istr.readPendingValues()
        let result = try await self.opCMap(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            CMapHelper.write(to: ostr, value: iceP_c2)
            CMapHelper.write(to: ostr, value: iceP_returnValue)
            ostr.writePendingValues()
        }
    }

    public func _iceD_shutdown(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        _ = try request.inputStream.skipEmptyEncapsulation()
        try await self.shutdown(current: request.current)
        return request.current.makeEmptyOutgoingResponse()
    }
}

extension FooI {
    public func _iceD_opS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: InnerS = try istr.read()
        let result = try await self.opS(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_c1: FooClass1?
        try istr.read(FooClass1.self) { iceP_c1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opC(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }
}

extension I {
    public func _iceD_opS(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        let iceP_s1: InnerS = try istr.read()
        let result = try await self.opS(s1: iceP_s1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_s2) = value
            ostr.write(iceP_s2)
            ostr.write(iceP_returnValue)
        }
    }

    public func _iceD_opC(_ request: Ice.IncomingRequest) async throws -> Ice.OutgoingResponse {
        
        let istr = request.inputStream
        _ = try istr.startEncapsulation()
        var iceP_c1: Class1?
        try istr.read(Class1.self) { iceP_c1 = $0 }
        try istr.readPendingValues()
        let result = try await self.opC(c1: iceP_c1, current: request.current)
        return request.current.makeOutgoingResponse(result, formatType: nil) { ostr, value in 
            let (iceP_returnValue, iceP_c2) = value
            ostr.write(iceP_c2)
            ostr.write(iceP_returnValue)
            ostr.writePendingValues()
        }
    }
}
